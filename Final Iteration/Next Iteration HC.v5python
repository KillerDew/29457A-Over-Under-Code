{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nleft_motor_a = Motor(Ports.PORT21, GearSetting.RATIO_18_1, False)\nleft_motor_b = Motor(Ports.PORT20, GearSetting.RATIO_18_1, False)\nleft_drive_smart = MotorGroup(left_motor_a, left_motor_b)\nright_motor_a = Motor(Ports.PORT19, GearSetting.RATIO_18_1, True)\nright_motor_b = Motor(Ports.PORT18, GearSetting.RATIO_18_1, True)\nright_drive_smart = MotorGroup(right_motor_a, right_motor_b)\ndrivetrain_inertial = Inertial(Ports.PORT17)\ndrivetrain = SmartDrive(left_drive_smart, right_drive_smart, drivetrain_inertial, 319.19, 320, 225, MM, 1)\nL_extra = Motor(Ports.PORT2, GearSetting.RATIO_18_1, False)\nR_extra = Motor(Ports.PORT1, GearSetting.RATIO_18_1, True)\nIntake_motor_a = Motor(Ports.PORT15, GearSetting.RATIO_18_1, False)\nIntake_motor_b = Motor(Ports.PORT16, GearSetting.RATIO_18_1, True)\nIntake = MotorGroup(Intake_motor_a, Intake_motor_b)\nWing = DigitalOut(brain.three_wire_port.a)\ncontroller_1 = Controller(PRIMARY)\nCatapult = Motor(Ports.PORT14, GearSetting.RATIO_36_1, False)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\ndef calibrate_drivetrain():\n    # Calibrate the Drivetrain Inertial\n    sleep(200, MSEC)\n    brain.screen.print(\"Calibrating\")\n    brain.screen.next_row()\n    brain.screen.print(\"Inertial\")\n    drivetrain_inertial.calibrate()\n    while drivetrain_inertial.is_calibrating():\n        sleep(25, MSEC)\n    brain.screen.clear_screen()\n    brain.screen.set_cursor(1, 1)\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n\n\n# define variables used for controlling motors based on controller inputs\ndrivetrain_needs_to_be_stopped_controller_1 = False\n\n# define a task that will handle monitoring inputs from controller_1\ndef rc_auto_loop_function_controller_1():\n    global drivetrain_needs_to_be_stopped_controller_1, remote_control_code_enabled\n    # process the controller input every 20 milliseconds\n    # update the motors based on the input values\n    while True:\n        if remote_control_code_enabled:\n            # stop the motors if the brain is calibrating\n            if drivetrain_inertial.is_calibrating():\n                left_drive_smart.stop()\n                right_drive_smart.stop()\n                while drivetrain_inertial.is_calibrating():\n                    sleep(25, MSEC)\n            \n            # calculate the drivetrain motor velocities from the controller joystick axies\n            # left = axis3 + axis4\n            # right = axis3 - axis4\n            drivetrain_left_side_speed = controller_1.axis3.position() + controller_1.axis4.position()\n            drivetrain_right_side_speed = controller_1.axis3.position() - controller_1.axis4.position()\n            \n            # check if the values are inside of the deadband range\n            if abs(drivetrain_left_side_speed) < 5 and abs(drivetrain_right_side_speed) < 5:\n                # check if the motors have already been stopped\n                if drivetrain_needs_to_be_stopped_controller_1:\n                    # stop the drive motors\n                    left_drive_smart.stop()\n                    right_drive_smart.stop()\n                    # tell the code that the motors have been stopped\n                    drivetrain_needs_to_be_stopped_controller_1 = False\n            else:\n                # reset the toggle so that the deadband code knows to stop the motors next\n                # time the input is in the deadband range\n                drivetrain_needs_to_be_stopped_controller_1 = True\n            \n            # only tell the left drive motor to spin if the values are not in the deadband range\n            if drivetrain_needs_to_be_stopped_controller_1:\n                left_drive_smart.set_velocity(drivetrain_left_side_speed, PERCENT)\n                left_drive_smart.spin(FORWARD)\n            # only tell the right drive motor to spin if the values are not in the deadband range\n            if drivetrain_needs_to_be_stopped_controller_1:\n                right_drive_smart.set_velocity(drivetrain_right_side_speed, PERCENT)\n                right_drive_smart.spin(FORWARD)\n        # wait before repeating the process\n        wait(20, MSEC)\n\n# define variable for remote controller enable/disable\nremote_control_code_enabled = True\n\nrc_auto_loop_thread_controller_1 = Thread(rc_auto_loop_function_controller_1)\n\n#endregion VEXcode Generated Robot Configuration\n\n# ------------------------------------------\n# \n# \tProject:      VEXcode Project\n#\tAuthor:       VEX\n#\tCreated:\n#\tDescription:  VEXcode V5 Python Project\n# \n# ------------------------------------------\n\n# Library imports\nfrom vex import *\nfrom math import cos, sin, radians, degrees\n# Begin project code\nclass ButtonUi:\n    class Button:\n        def __init__(self):\n            self.index = 0\n            self.xpos = 0\n            self.ypos = 0\n            self.width = 80\n            self.height = 80\n            self.color = Color.WHITE\n            self.text = ''\n            self.alttext = ''\n            self.state = False\n            self.toggle = False\n            self.callback = None\n\n        def set_toggle(self, toggle, text):\n            self.toggle = toggle\n            if text is not None:\n                self.alttext = text\n            else:\n                self.alttext = self.text\n            return self\n\n        def set_size(self, width, height):\n            self.width = width\n            self.height = height\n            return self\n\n        def set_color(self, color):\n            self.color = color\n            return self\n\n    def __init__(self):\n        self.brain = Brain()\n        self._buttons = []\n        self._enabled = True\n        self.brain.screen.pressed(self._screen_press)\n        self.brain.screen.released(self._screen_release)\n\n    @staticmethod\n    def _find_button(b, xpos, ypos):\n        if xpos < b.xpos or xpos > (b.xpos + b.width):\n            return False\n\n        if ypos < b.ypos or ypos > (b.ypos + b.height):\n            return False\n\n        return True\n\n    def _draw_button(self, b, bHighlight):\n        if bHighlight:\n            self.brain.screen.draw_rectangle(\n                b.xpos, b.ypos, b.width, b.height, Color(0x808080))\n        else:\n            self.brain.screen.draw_rectangle(\n                b.xpos, b.ypos, b.width, b.height, b.color)\n\n        self.brain.screen.draw_rectangle(\n            b.xpos, b.ypos, b.width, b.height, Color.TRANSPARENT)\n        self.brain.screen.set_fill_color(Color.BLACK)\n        self.brain.screen.set_pen_color(Color.WHITE)\n        self.brain.screen.set_font(FontType.MONO20)\n\n        if b.toggle and b.state:\n            text = b.alttext\n        else:\n            text = b.text\n        # we need to add twxt width to python VM, this will do for now\n        textwidth = len(text) * 10\n        self.brain.screen.print_at(\n            text, opaque=False, x=b.xpos + (b.width-textwidth)/2, y=b.ypos + b.height/2 + 10)\n\n    def _draw_buttons(self):\n        for b in self._buttons:\n            self._draw_button(b, False)\n\n    def _screen_press(self):\n        if not self._enabled:\n            return\n\n        xpos = self.brain.screen.x_position()\n        ypos = self.brain.screen.y_position()\n\n        for b in self._buttons:\n            if self._find_button(b, xpos, ypos):\n                if b.toggle is True:\n                    b.state = not b.state\n                else:\n                    b.state = True\n\n                self._draw_button(b, True)\n                if b.callback is not None:\n                    b.callback(b.index, b.state)\n                return\n\n    def _screen_release(self):\n        if not self._enabled:\n            return\n\n        for b in self._buttons:\n            if not b.toggle:\n                if b.state:\n                    b.state = False\n                    if b.callback is not None:\n                        b.callback(b.index, b.state)\n\n        self._draw_buttons()\n\n    def add_button(self, x, y, text, callback):\n        b = ButtonUi.Button()\n        b.index = len(self._buttons)\n        b.xpos = x\n        b.ypos = y\n        b.text = text\n        b.callback = callback\n        self._buttons.append(b)\n        return b\n\n    def enable(self):\n        self._enabled = True\n\n    def disable(self):\n        self._enabled = False\n\n    def display(self, bClearScreen=False):\n        if bClearScreen:\n            self.brain.screen.clear_screen()\n        self._draw_buttons()\n\n\n\n# Displays a single value on screen\ndef displaySingle(a):\n    brain.screen.clear_screen()\n    brain.screen.set_cursor(1,1)\n    brain.screen.print(a)\ndef BuzzController(pattern = \"...\"):\n    controller_1.rumble(pattern)\ndef BuzzAtEnd():\n    wait(85, SECONDS)\n    BuzzController()\n    for x in range(2):\n        wait(5, SECONDS)\n        BuzzController(\"-\")\ndef AddVector(a, b):\n    if len(a) != len(b):\n        return a\n    new = []\n    for x in range(len(a)):\n        new.append(a[x]+b[x])\n    return new\n\n#Function to calculate heading of vector a\ndef HeadingFromVector(a):\n    if a[0] < 0 and a[1] >= 0:\n        return 450 - math.degrees(math.atan2(a[1], a[0]))\n    else:\n        return 90 - math.degrees(math.atan2(a[1], a[0]))\n# Function to calculate magnitude of vector a\ndef Magnitude(a):\n    b = (a[0]**2)+(a[1]**2)\n    return math.sqrt(b)\n# We had problems with the default 'turn_to_heading() function, so this is a replacement that halts\n# the program while we turn to the correct heading\ndef WaitUntilHeading(Heading, error):\n    while True:\n        wait(5, MSEC)\n        if drivetrain_inertial.heading(DEGREES) <= Heading+error and drivetrain_inertial.heading(DEGREES) >= Heading-error:\n            break\n\n\"\"\"\nThis Function Calculates the shortest rotation between the current heading 'T' and the\ntarget heading 'C'\n\"\"\"\ndef ShortestRotation(T, C):\n    diff = abs(T-C)\n\n    if diff <= 180:\n        return LEFT if C > T else RIGHT\n    else:\n        return LEFT if C < T else RIGHT\n# test function to monitor heading during auto period\ndef HeadingDisp():\n    while True:\n        brain.screen.clear_screen()\n        brain.screen.set_cursor(1,1)\n        brain.screen.print(drivetrain_inertial.heading(DEGREES))\n        wait(0.02, SECONDS)\nDefensiveIntakeTimings = [\n    [0, True],\n    [3, None],\n    [6, False]\n]\nOffensiveIntakeTimings = [\n\n]\nDefensivePath = [\n    [0, 800, True, True, False],\n    [0, 0, False, False, False]\n]\nOffensivePath = [\n\n]\nOffensive = False\ndef ToggleOffensive(index, state):\n    global Offensive\n    Offensive = not Offensive\nStartOffset = [0, 0]\nStartHeadingOffset = 0\nIntakeTimings = []\ndef DoIntakeTimings():\n    for x in IntakeTimings:\n        if x[1] == None:\n            Intake.stop()\n        else:\n            Intake.spin(FORWARD if x[1] else REVERSE)\n        wait(x[0])\n# Main autonomous function\ndef autonomous():\n    del ui\n    brain.screen.clear_screen()\n    brain.screen.set_fill_color(Color.RED)\n    brain.screen.draw_rectangle(0, 0, 479, 239)\n    brain.screen.set_cursor(150, 150)\n    brain.screen.print(\"AUTONOMOUS RUNNING\")\n    global IntakeTimings\n    if Offensive:\n        AutoPathChosen = OffensivePath\n        IntakeTimings = OffensiveIntakeTimings\n    else:\n        AutoPathChosen = DefensivePath\n        IntakeTimings = DefensiveIntakeTimings\n    drivetrain_inertial.set_heading(StartHeadingOffset,DEGREES)\n    # Set turn velocity to low value for accuracy\n    drivetrain.set_turn_velocity(20, PERCENT)\n    #OnUpArrowPress()\n\n    Commands = []\n    First = True\n    # Loops through path formulating commands\n    for x in range(len(AutoPathChosen)):\n        # 'V2Pos' is the vector from one path point to the next\n        # Calculated by V = [Xn - Xn-1, Yn - Yn-1]\n        # However, if we are on the first element, Xn-1 and Yn-1 do not exist, so we can asign them to 0\n        # Making the Vector simply [Xn - 0, Yn - 0] -> [Xn, Yn]\n        if First:\n            First = False\n            V2Pos = [AutoPathChosen[x][0]-StartOffset[0], AutoPathChosen[x][1]-StartOffset[1]]\n        else:\n            V2Pos = [AutoPathChosen[x][0]-AutoPathChosen[x-1][0], AutoPathChosen[x][1]-AutoPathChosen[x-1][1]]\n\n        # Calculate heading of vector, to be used in commands\n        Heading2Pos = HeadingFromVector(V2Pos)\n\n        # Magnitude to determine how much the robot needs to move forward or backward\n        DriveDist = Magnitude(V2Pos)\n\n        # If the robot needs to reverse to position, 180 Deg must be added to the heading\n        if AutoPathChosen[x][2] != True:\n            Heading2Pos = (180+Heading2Pos) % 360\n        else:\n            DriveDist = -DriveDist\n        \n        # Add heading and forward movement to command list\n        Commands.append([Heading2Pos, DriveDist, AutoPathChosen[x][3], AutoPathChosen[x][4]])\n        \n    # Loop through commands and excecute them\n    brain.screen.print(Commands)\n    for x in Commands:\n        Thread(DoIntakeTimings)\n        if x == Commands[len(Commands)-1]:\n            pass\n            #OnUpArrowPress()\n        # Uses 'ShortestRotation()' to decide wether to turn left or right\n        # -- Replaces drivetrain.turn_to_heading()\n        drivetrain.turn(ShortestRotation(x[0], drivetrain_inertial.heading(DEGREES)))\n        WaitUntilHeading(x[0], 2)\n        drivetrain.stop()\n        # --\n        if x[2] == True:\n            SetVelocity(65)\n        else:\n            SetVelocity(35)\n        Wing.set(x[3])\n        drivetrain.drive_for(REVERSE, x[1], MM, wait=True)\n    brain.screen.clear_screen()\n    brain.screen.set_fill_color(Color.BLUE)\n    brain.screen.draw_rectangle(0, 0, 479, 239)\n    brain.screen.set_cursor(150, 150)\n    brain.screen.print(\"AUTONOMOUS FINISHED\")       \n\n\"\"\"\n'Drive()' Function:\n- A function designed to be used in a thread\n- Sets the left extra motor's speed to the drivetrain left side's velocity\n- Sets the right extra motor's speed to the drivetrain right side's velocity\n- Some lag created in extra wheels - more prominent on 'COAST' stopping mode, mitigated on 'BRAKE' mode\n- Allows traditional driving controls to be used on a 6 motor drivetrain.\n\"\"\"\ndef Drive():\n    L_extra.spin(FORWARD)\n    R_extra.spin(FORWARD)\n    while True:\n        wait(0.1, MSEC)\n        L_extra.set_velocity(left_motor_b.velocity(PERCENT), PERCENT)\n        R_extra.set_velocity(right_motor_b.velocity(PERCENT), PERCENT)\n\n# 'SetStopping()' - Sets all motors (drivetrain and extra motors) to the given stopping mode\ndef SetStopping(stopping):\n    drivetrain.set_stopping(stopping)\n    L_extra.set_stopping(stopping)\n    R_extra.set_stopping(stopping)\n\n# 'SetVelocity()' - Sets all motors (drivetrain and extra motors) to the given velocity\ndef SetVelocity(vel):\n    drivetrain.set_drive_velocity(vel, PERCENT)\n    L_extra.set_velocity(vel, PERCENT)\n    R_extra.set_velocity(vel, PERCENT)\n\n# 'OnXPress()' - for the catapult, sets the catapult to spin, and sets drivetrain stopping to HOLD so we are\n#  harder to move while mathc loading (less succeptable to bullying)\ndef OnXPress():\n    Catapult.spin(FORWARD)\n    SetStopping(HOLD)\n\n# 'OnXRelease()' - for the catapult, stops the catapult and sets drivetrain stopping back to BRAKE\ndef OnXRelease():\n    Catapult.stop()\n    SetStopping(BRAKE)\n\n# 'OnR1Press()' - toggles wing (A-symetrical)\nWING = False\ndef OnR1Press():\n    global WING\n    WING = not WING\n    Wing.set(WING)\n\n# 'OnL1Press()' - toggles a 'boost' mode, which switches drivetrain between a slower speed for maneuverability and\n#   a high speed for straight lines.\nBoost = False\nHighSpeed = 50\nLowSpeed = 10\ndef OnL1Press():\n    global Boost\n    Boost = not Boost\n    SetVelocity(HighSpeed if Boost else LowSpeed)\ndef OnL2Press():\n    Intake.spin(FORWARD)\ndef OnR2Press():\n    Intake.spin(REVERSE)\ndef StopIntake():\n    Intake.stop()\n# Makes a thread for 'Drive()'\nThread(Drive)\n# 'driver_control()' - sets speed and stopping mode\ndef driver_control():\n    SetVelocity(10) \n    SetStopping(BRAKE)\n    BuzzAtEnd()\n\n# other misc\ncompetition = Competition(driver_control, autonomous) \n\ncontroller_1.buttonX.pressed(OnXPress)\n\ncontroller_1.buttonX.released(OnXRelease)\n\ncontroller_1.buttonR1.pressed(OnR1Press)\n\ncontroller_1.buttonL1.pressed(OnL1Press)\n\ncontroller_1.buttonR2.pressed(OnR2Press)\ncontroller_1.buttonL2.pressed(OnL2Press)\ncontroller_1.buttonR2.released(StopIntake)\ncontroller_1.buttonL2.released(StopIntake)\n\nCatapult.set_velocity(40, PERCENT)\nCatapult.set_stopping(HOLD)\ncalibrate_drivetrain()\nui = ButtonUi()\nui.add_button(150, 150, \"Defensive\", ToggleOffensive).set_toggle(True, \"Offensive\")\n\n","textLanguage":"python","rconfig":[{"port":[21,20,19,18,17],"name":"drivetrain","customName":false,"deviceType":"Drivetrain","deviceClass":"smartdrive","setting":{"type":"4-motor","wheelSize":"wheel4in","gear":"ratio18_1","gearRatio":"1:1","direction":"fwd","gyroType":"inertial","width":"320","unit":"mm","wheelbase":"225","wheelbaseUnit":"mm","xOffset":"0","xOffsetUnit":"mm","yOffset":"0","yOffsetUnit":"mm","thetaOffset":"180"},"triportSourcePort":null},{"port":[2],"name":"L_extra","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[1],"name":"R_extra","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[15,16],"name":"Intake","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","gear":"ratio18_1","motor_a_reversed":"false","motor_b_reversed":"true"},"triportSourcePort":22},{"port":[1],"name":"Wing","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":22},{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"arcadel","id":"primary"},"triportSourcePort":22},{"port":[14],"name":"Catapult","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio36_1"},"triportSourcePort":22}],"slot":2,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"3.0.5","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}