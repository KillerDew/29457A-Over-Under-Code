{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nleft_motor_a = Motor(Ports.PORT10, GearSetting.RATIO_18_1, False)\nleft_motor_b = Motor(Ports.PORT15, GearSetting.RATIO_18_1, False)\nleft_drive_smart = MotorGroup(left_motor_a, left_motor_b)\nright_motor_a = Motor(Ports.PORT8, GearSetting.RATIO_18_1, True)\nright_motor_b = Motor(Ports.PORT9, GearSetting.RATIO_18_1, True)\nright_drive_smart = MotorGroup(right_motor_a, right_motor_b)\ndrivetrain_inertial = Inertial(Ports.PORT6)\ndrivetrain = SmartDrive(left_drive_smart, right_drive_smart, drivetrain_inertial, 319.19, 320, 225, MM, 1)\nL_extra = Motor(Ports.PORT2, GearSetting.RATIO_18_1, False)\nR_extra = Motor(Ports.PORT1, GearSetting.RATIO_18_1, True)\nCatapult_motor_a = Motor(Ports.PORT13, GearSetting.RATIO_36_1, False)\nCatapult_motor_b = Motor(Ports.PORT3, GearSetting.RATIO_36_1, True)\nCatapult = MotorGroup(Catapult_motor_a, Catapult_motor_b)\nWing = DigitalOut(brain.three_wire_port.a)\ncontroller_1 = Controller(PRIMARY)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\ndef calibrate_drivetrain():\n    # Calibrate the Drivetrain Inertial\n    sleep(200, MSEC)\n    brain.screen.print(\"Calibrating\")\n    brain.screen.next_row()\n    brain.screen.print(\"Inertial\")\n    drivetrain_inertial.calibrate()\n    while drivetrain_inertial.is_calibrating():\n        sleep(25, MSEC)\n    brain.screen.clear_screen()\n    brain.screen.set_cursor(1, 1)\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n\n\n# define variables used for controlling motors based on controller inputs\ndrivetrain_needs_to_be_stopped_controller_1 = False\n\n# define a task that will handle monitoring inputs from controller_1\ndef rc_auto_loop_function_controller_1():\n    global drivetrain_needs_to_be_stopped_controller_1, remote_control_code_enabled\n    # process the controller input every 20 milliseconds\n    # update the motors based on the input values\n    while True:\n        if remote_control_code_enabled:\n            # stop the motors if the brain is calibrating\n            if drivetrain_inertial.is_calibrating():\n                left_drive_smart.stop()\n                right_drive_smart.stop()\n                while drivetrain_inertial.is_calibrating():\n                    sleep(25, MSEC)\n            \n            # calculate the drivetrain motor velocities from the controller joystick axies\n            # left = axis3 + axis4\n            # right = axis3 - axis4\n            drivetrain_left_side_speed = controller_1.axis3.position() + controller_1.axis4.position()\n            drivetrain_right_side_speed = controller_1.axis3.position() - controller_1.axis4.position()\n            \n            # check if the values are inside of the deadband range\n            if abs(drivetrain_left_side_speed) < 5 and abs(drivetrain_right_side_speed) < 5:\n                # check if the motors have already been stopped\n                if drivetrain_needs_to_be_stopped_controller_1:\n                    # stop the drive motors\n                    left_drive_smart.stop()\n                    right_drive_smart.stop()\n                    # tell the code that the motors have been stopped\n                    drivetrain_needs_to_be_stopped_controller_1 = False\n            else:\n                # reset the toggle so that the deadband code knows to stop the motors next\n                # time the input is in the deadband range\n                drivetrain_needs_to_be_stopped_controller_1 = True\n            \n            # only tell the left drive motor to spin if the values are not in the deadband range\n            if drivetrain_needs_to_be_stopped_controller_1:\n                left_drive_smart.set_velocity(drivetrain_left_side_speed, PERCENT)\n                left_drive_smart.spin(FORWARD)\n            # only tell the right drive motor to spin if the values are not in the deadband range\n            if drivetrain_needs_to_be_stopped_controller_1:\n                right_drive_smart.set_velocity(drivetrain_right_side_speed, PERCENT)\n                right_drive_smart.spin(FORWARD)\n        # wait before repeating the process\n        wait(20, MSEC)\n\n# define variable for remote controller enable/disable\nremote_control_code_enabled = True\n\nrc_auto_loop_thread_controller_1 = Thread(rc_auto_loop_function_controller_1)\n\n#endregion VEXcode Generated Robot Configuration\n\n# ------------------------------------------\n# \n# \tProject:      VEXcode Project\n#\tAuthor:       VEX\n#\tCreated:\n#\tDescription:  VEXcode V5 Python Project\n# \n# ------------------------------------------\n\n# Library imports\nfrom vex import *\nfrom math import cos, sin, radians, degrees\n# Begin project code\ndef displaySingle(a):\n    brain.screen.clear_screen()\n    brain.screen.set_cursor(1,1)\n    brain.screen.print(a)\ndef AddVector(a, b):\n    if len(a) != len(b):\n        return a\n    new = []\n    for x in range(len(a)):\n        new.append(a[x]+b[x])\n    return new\n\n#Function to calculate heading of vector a\ndef HeadingFromVector(a):\n    if a[0] < 0 and a[1] >= 0:\n        return 450 - math.degrees(math.atan2(a[1], a[0]))\n    else:\n        return 90 - math.degrees(math.atan2(a[1], a[0]))\n# Function to calculate magnitude of vector a\ndef Magnitude(a):\n    b = (a[0]**2)+(a[1]**2)\n    return math.sqrt(b)\n# We had problems with the default 'turn_to_heading() function, so this is a replacement that halts\n# the program while we turn to the correct heading\ndef WaitUntilHeading(Heading, error):\n    while True:\n        wait(5, MSEC)\n        if drivetrain_inertial.heading(DEGREES) <= Heading+error and drivetrain_inertial.heading(DEGREES) >= Heading-error:\n            break\n\n\"\"\"\nThis Function Calculates the shortest rotation between the current heading 'T' and the\ntarget heading 'C'\n\"\"\"\ndef ShortestRotation(T, C):\n    diff = abs(T-C)\n\n    if diff <= 180:\n        return LEFT if C > T else RIGHT\n    else:\n        return LEFT if C < T else RIGHT\n# test function to monitor heading during auto period\ndef HeadingDisp():\n    while True:\n        brain.screen.clear_screen()\n        brain.screen.set_cursor(1,1)\n        brain.screen.print(drivetrain_inertial.heading(DEGREES))\n        wait(0.02, SECONDS)\nAutoPathChosen = [\n    [-330, 1070, True, True, False],\n    [-513, 530, False, False, False],\n    [-890, 1150, True, False, False],\n    [-890, 1480, True, False, False],\n    [-1590, 1470, True, True, True]\n]\nStartOffset = [-513, 510]\nStartHeadingOffset = 15\n# Main autonomous function\ndef autonomous():\n    drivetrain_inertial.calibrate()\n    wait(2,SECONDS)\n    drivetrain_inertial.set_heading(StartHeadingOffset,DEGREES)\n    # Set turn velocity to low value for accuracy\n    drivetrain.set_turn_velocity(20, PERCENT)\n    #OnUpArrowPress()\n\n    Commands = []\n    First = True\n    # Loops through path formulating commands\n    for x in range(len(AutoPathChosen)):\n        # 'V2Pos' is the vector from one path point to the next\n        # Calculated by V = [Xn - Xn-1, Yn - Yn-1]\n        # However, if we are on the first element, Xn-1 and Yn-1 do not exist, so we can asign them to 0\n        # Making the Vector simply [Xn - 0, Yn - 0] -> [Xn, Yn]\n        if First:\n            First = False\n            V2Pos = [AutoPathChosen[x][0]-StartOffset[0], AutoPathChosen[x][1]-StartOffset[1]]\n        else:\n            V2Pos = [AutoPathChosen[x][0]-AutoPathChosen[x-1][0], AutoPathChosen[x][1]-AutoPathChosen[x-1][1]]\n\n        # Calculate heading of vector, to be used in commands\n        Heading2Pos = HeadingFromVector(V2Pos)\n\n        # Magnitude to determine how much the robot needs to move forward or backward\n        DriveDist = Magnitude(V2Pos)\n\n        # If the robot needs to reverse to position, 180 Deg must be added to the heading\n        if AutoPathChosen[x][2] != True:\n            Heading2Pos = (180+Heading2Pos) % 360\n        else:\n            DriveDist = -DriveDist\n        \n        # Add heading and forward movement to command list\n        Commands.append([Heading2Pos, DriveDist, AutoPathChosen[x][3], AutoPathChosen[x][4]])\n        \n    # Loop through commands and excecute them\n    brain.screen.print(Commands)\n    for x in Commands:\n        if x == Commands[len(Commands)-1]:\n            pass\n            #OnUpArrowPress()\n        # Uses 'ShortestRotation()' to decide wether to turn left or right\n        # -- Replaces drivetrain.turn_to_heading()\n        drivetrain.turn(ShortestRotation(x[0], drivetrain_inertial.heading(DEGREES)))\n        WaitUntilHeading(x[0], 2)\n        drivetrain.stop()\n        # --\n        if x[2] == True:\n            SetVelocity(65)\n        else:\n            SetVelocity(35)\n        Wing.set(x[3])\n        drivetrain.drive_for(REVERSE, x[1], MM, wait=True)\n\ndef Drive():\n    L_extra.spin(FORWARD)\n    R_extra.spin(FORWARD)\n    while True:\n        wait(0.1, MSEC)\n        L_extra.set_velocity(left_motor_b.velocity(PERCENT), PERCENT)\n        R_extra.set_velocity(right_motor_b.velocity(PERCENT), PERCENT)\n\ndef SetStopping(stopping):\n    drivetrain.set_stopping(stopping)\n    L_extra.set_stopping(stopping)\n    R_extra.set_stopping(stopping)\n\ndef SetVelocity(vel):\n    drivetrain.set_drive_velocity(vel, PERCENT)\n    L_extra.set_velocity(vel, PERCENT)\n    R_extra.set_velocity(vel, PERCENT)\n\n\ndef OnXPress():\n    Catapult.spin(FORWARD)\n    SetStopping(HOLD)\ndef OnXRelease():\n    Catapult.stop()\n    SetStopping(BRAKE)\nWING = False\ndef OnR1Press():\n    global WING\n    WING = not WING\n    Wing.set(WING)\n\nThread(Drive)\ndef driver_control():\n    SetVelocity(10)\n    SetStopping(BRAKE)\ncompetition = Competition(driver_control, autonomous) \ncontroller_1.buttonX.pressed(OnXPress)\ncontroller_1.buttonX.released(OnXRelease)\ncontroller_1.buttonR1.pressed(OnR1Press)\nCatapult.set_velocity(40, PERCENT)\nCatapult.set_stopping(HOLD)\ncalibrate_drivetrain()\nSetVelocity(10)\nSetStopping(BRAKE)\nautonomous()\ndriver_control()\n\n","textLanguage":"python","rconfig":[{"port":[10,15,8,9,6],"name":"drivetrain","customName":false,"deviceType":"Drivetrain","deviceClass":"smartdrive","setting":{"type":"4-motor","wheelSize":"wheel4in","gear":"ratio18_1","gearRatio":"1:1","direction":"fwd","gyroType":"inertial","width":"320","unit":"mm","wheelbase":"225","wheelbaseUnit":"mm","xOffset":"0","xOffsetUnit":"mm","yOffset":"0","yOffsetUnit":"mm","thetaOffset":"180"},"triportSourcePort":null},{"port":[2],"name":"L_extra","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[1],"name":"R_extra","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[13,3],"name":"Catapult","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","gear":"ratio36_1","motor_a_reversed":"false","motor_b_reversed":"true"},"triportSourcePort":22},{"port":[1],"name":"Wing","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":22},{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"arcadel","id":"primary"},"triportSourcePort":22}],"slot":2,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"3.0.4","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}