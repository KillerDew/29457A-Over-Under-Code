#region VEXcode Generated Robot Configuration
from vex import *
import urandom

# Brain should be defined by default
brain=Brain()

# Robot configuration code
controller_1 = Controller(PRIMARY)
Catapult_motor_a = Motor(Ports.PORT6, GearSetting.RATIO_36_1, False)
Catapult_motor_b = Motor(Ports.PORT10, GearSetting.RATIO_36_1, True)
Catapult = MotorGroup(Catapult_motor_a, Catapult_motor_b)
left_motor_a = Motor(Ports.PORT2, GearSetting.RATIO_18_1, False)
left_motor_b = Motor(Ports.PORT4, GearSetting.RATIO_18_1, False)
left_drive_smart = MotorGroup(left_motor_a, left_motor_b)
right_motor_a = Motor(Ports.PORT1, GearSetting.RATIO_18_1, True)
right_motor_b = Motor(Ports.PORT3, GearSetting.RATIO_18_1, True)
right_drive_smart = MotorGroup(right_motor_a, right_motor_b)
drivetrain_inertial = Inertial(Ports.PORT9)
drivetrain = SmartDrive(left_drive_smart, right_drive_smart, drivetrain_inertial, 319.19, 320, 40, MM, 1)
Wing_A = DigitalOut(brain.three_wire_port.a)
Wing_B = DigitalOut(brain.three_wire_port.b)


# wait for rotation sensor to fully initialize
wait(30, MSEC)

def calibrate_drivetrain():
    # Calibrate the Drivetrain Inertial
    sleep(200, MSEC)
    brain.screen.print("Calibrating")
    brain.screen.next_row()
    brain.screen.print("Inertial")
    drivetrain_inertial.calibrate()
    while drivetrain_inertial.is_calibrating():
        sleep(25, MSEC)
    brain.screen.clear_screen()
    brain.screen.set_cursor(1, 1)


def play_vexcode_sound(sound_name):
    # Helper to make playing sounds from the V5 in VEXcode easier and
    # keeps the code cleaner by making it clear what is happening.
    print("VEXPlaySound:" + sound_name)
    wait(5, MSEC)

# add a small delay to make sure we don't print in the middle of the REPL header
wait(200, MSEC)
# clear the console to make sure we don't have the REPL in the console
print("\033[2J")



# define variables used for controlling motors based on controller inputs
drivetrain_needs_to_be_stopped_controller_1 = False

# define a task that will handle monitoring inputs from controller_1
def rc_auto_loop_function_controller_1():
    global drivetrain_needs_to_be_stopped_controller_1, remote_control_code_enabled
    # process the controller input every 20 milliseconds
    # update the motors based on the input values
    while True:
        if remote_control_code_enabled:
            # stop the motors if the brain is calibrating
            if drivetrain_inertial.is_calibrating():
                left_drive_smart.stop()
                right_drive_smart.stop()
                while drivetrain_inertial.is_calibrating():
                    sleep(25, MSEC)
            
            # calculate the drivetrain motor velocities from the controller joystick axies
            # left = axis3 + axis4
            # right = axis3 - axis4
            drivetrain_left_side_speed = controller_1.axis3.position() + controller_1.axis4.position()
            drivetrain_right_side_speed = controller_1.axis3.position() - controller_1.axis4.position()
            
            # check if the values are inside of the deadband range
            if abs(drivetrain_left_side_speed) < 5 and abs(drivetrain_right_side_speed) < 5:
                # check if the motors have already been stopped
                if drivetrain_needs_to_be_stopped_controller_1:
                    # stop the drive motors
                    left_drive_smart.stop()
                    right_drive_smart.stop()
                    # tell the code that the motors have been stopped
                    drivetrain_needs_to_be_stopped_controller_1 = False
            else:
                # reset the toggle so that the deadband code knows to stop the motors next
                # time the input is in the deadband range
                drivetrain_needs_to_be_stopped_controller_1 = True
            
            # only tell the left drive motor to spin if the values are not in the deadband range
            if drivetrain_needs_to_be_stopped_controller_1:
                left_drive_smart.set_velocity(drivetrain_left_side_speed, PERCENT)
                left_drive_smart.spin(FORWARD)
            # only tell the right drive motor to spin if the values are not in the deadband range
            if drivetrain_needs_to_be_stopped_controller_1:
                right_drive_smart.set_velocity(drivetrain_right_side_speed, PERCENT)
                right_drive_smart.spin(FORWARD)
        # wait before repeating the process
        wait(20, MSEC)

# define variable for remote controller enable/disable
remote_control_code_enabled = True

rc_auto_loop_thread_controller_1 = Thread(rc_auto_loop_function_controller_1)

#endregion VEXcode Generated Robot Configuration

# ------------------------------------------
# 
# 	Project:      Main Drive Script
#	Author:       Daniel Dew, Daniel DaSliva
#	Created:      2023/4
#	Description:  Code for St Christopher's robotics team - contains both autonomous and driver control scripting
# 
# ------------------------------------------

# Library imports
from vex import *
import math

"""
------ The Autonomous Period: ------
Goals:
- Move Objective triball into goal
- Navigate Back to match load position

Excecution:

-- Method 1: --
Full autonomous navigation - using the inertial sensor to estimate position,
then navigate along path.

Structure:

Sensor -> Navigation system (position est.) -> Pure Pursuit (Error to path)
-> PID(s) (Move to path)

Pros: Allows for hardware errors (slight drifts and/or turns) to be negated
Cons: Complex and subject to sensor noise

We decided against implementing this for our first competition, as their were to many
parameters to tune and not enough time to test them.
Howver, we do plan on implementing this on further competitions - as it shows our robot's
ability to adapt to different paths.

-- Method 2: --
'Hard Coded Pathfinding' - using path to formulate step-by-step commands.

Structure:
Path -> Commands
e.g
A path of
[0, 0]
[0, 1000]
[-1000, 1000]

Goes to Commands:
[0, 1000]
[270, 1000]

In the Commands array, the first element of each command is the heading required to align
the robot to the next path point then the seccond element is the required ammount of forward movement,
in MM.

Pros:
Simple - easy to implement with VEX API

Cons:
Margin for Error - if drift or hardware errors occur, the robot cannot correc for
them, so any errors made stack up and can accumulate into large errors.
No smoothed path following - whithout pure pursuit (a program to intercept the path),
the robot follows the points, and not an interpolated path between them. This can cause
the robot to make jerky, sharp turns.


"""


"""
For the autonomous period, there are 2 starting positions, therefore the path for
required for each is different, one requires a left turn, while the other requires a right turn.
So, we use two paths and select one before the start.

The arrays have 3 elements, the first 2 are x and y position values
and the 3rd one is wether the robot should reverse to the position (False) or drive normally
to it (True). The last one is wether the robot should use increased speed, in order to push the ball under the goal.
"""


AutoPath1 = [
    [0, 950, False, False],
    [-340, 950, False, False],
    [200, 940, True, False],
    [-340, 940, True, True, True],
    [200, 950, False, False],
    [-600, 0, False, False, False]
]

AutoPath2 = [
    [0, 940, False, False],
    [300, 950, False, False],
    [-200, 940, True, False],
    [290, 940, True, True],
    [-100, 940, True, False],
    [600, 0, False, False]
]
CanPress = True
#Function to display path choices - used before comp start
def DisplayChoices():
    CanPress = True
 
    brain.screen.set_fill_color(Color.WHITE)
    brain.screen.set_pen_color(Color.BLACK)
    brain.screen.set_cursor(240, 120)
    brain.screen.print("SELECT AUTONOMOUS PATH")

    wait(1, SECONDS)
    
    # Box 1
    brain.screen.clear_screen()
    brain.screen.set_fill_color(Color.BLUE)
    brain.screen.draw_rectangle(0, 0, 240, 240)
    brain.screen.set_cursor(10, 0)
    brain.screen.print("PATH 1")

    # Box 2
    brain.screen.set_fill_color(Color.RED)
    brain.screen.draw_rectangle(240, 0, 240, 240)
    brain.screen.set_cursor(20, 0)
    brain.screen.print("PATH 2")
AutoPathChosen = AutoPath1
# Function to register which path has been selected
def ChoosePath():
    global CanPress
    if not CanPress:
        return
    x = brain.screen.x_position()
    y = brain.screen.y_position()
    #Check which box has been pressed and asign Chosen Path to corresponding path
    if x > 0 and x < 240:
        AutoPathChosen = AutoPath1
    elif x >= 240:
        AutoPathChosen = AutoPath2
    else:
        return
    CanPress = False
    brain.screen.clear_screen()
    brain.screen.set_cursor(1,1)
    brain.screen.print("Chosen Path")

#Function to calculate heading of vector a
def HeadingFromVector(a):
    if a[0] < 0 and a[1] >= 0:
        return 450 - math.degrees(math.atan2(a[1], a[0]))
    else:
        return 90 - math.degrees(math.atan2(a[1], a[0]))
# Function to calculate magnitude of vector a
def Magnitude(a):
    b = (a[0]**2)+(a[1]**2)
    return math.sqrt(b)
# We had problems with the default 'turn_to_heading() function, so this is a replacement that halts
# the program while we turn to the correct heading
def WaitUntilHeading(Heading, error):
    while True:
        wait(5, MSEC)
        if drivetrain_inertial.heading(DEGREES) <= Heading+error and drivetrain_inertial.heading(DEGREES) >= Heading-error:
            break

"""
This Function Calculates the shortest rotation between the current heading 'T' and the
target heading 'C'
"""
def ShortestRotation(T, C):
    diff = abs(T-C)

    if diff <= 180:
        return LEFT if C > T else RIGHT
    else:
        return LEFT if C < T else RIGHT
# test function to monitor heading during auto period
def HeadingDisp():
    while True:
        brain.screen.clear_screen()
        brain.screen.set_cursor(1,1)
        brain.screen.print(drivetrain_inertial.heading(DEGREES))
        wait(0.02, SECONDS)
# -- On holding of the button X, we want the catapult to continously move until X is released
def OnXPress():
    Catapult.set_velocity(40, PERCENT)
    Catapult.spin(REVERSE)
def OnXRelease():
    Catapult.stop()
def OnBPress():
    Catapult.set_velocity(20, PERCENT)
    Catapult.spin(FORWARD)
def OnBRelease():
    Catapult.stop()

A_Wing = False
B_Wing = False
def OnUpArrowPress():
    global A_Wing
    global B_Wing
    A_Wing = not A_Wing
    B_Wing = not B_Wing
    Wing_A.set(A_Wing)
    Wing_B.set(B_Wing)
def OnLeftBumperPress():
    global A_Wing
    A_Wing = not A_Wing
    Wing_A.set(A_Wing)
def OnRightBumperPress():
    global B_Wing
    B_Wing = not B_Wing
    Wing_B.set(B_Wing)

# -- 
# Main autonomous function
def autonomous():
    drivetrain_inertial.calibrate()
    drivetrain_inertial.set_heading(180,DEGREES)
    wait(2,SECONDS)
    # Set turn velocity to low value for accuracy
    drivetrain.set_turn_velocity(10, PERCENT)

    Commands = []
    First = True
    # Loops through path formulating commands
    for x in range(len(AutoPathChosen)):
        # 'V2Pos' is the vector from one path point to the next
        # Calculated by V = [Xn - Xn-1, Yn - Yn-1]
        # However, if we are on the first element, Xn-1 and Yn-1 do not exist, so we can asign them to 0
        # Making the Vector simply [Xn - 0, Yn - 0] -> [Xn, Yn]
        WingExpands = []
        if len(AutoPathChosen[x]) == 5:
            WingExpands.append(x)
            brain.screen.print("l")
        if First:
            First = False
            V2Pos = [AutoPathChosen[x][0], AutoPathChosen[x][1]]
        else:
            V2Pos = [AutoPathChosen[x][0]-AutoPathChosen[x-1][0], AutoPathChosen[x][1]-AutoPathChosen[x-1][1]]

        # Calculate heading of vector, to be used in commands
        Heading2Pos = HeadingFromVector(V2Pos)

        # Magnitude to determine how much the robot needs to move forward or backward
        DriveDist = Magnitude(V2Pos)

        # If the robot needs to reverse to position, 180 Deg must be added to the heading
        if AutoPathChosen[x][2] != True:
            Heading2Pos = (180+Heading2Pos) % 360
        else:
            DriveDist = -DriveDist
        
        # Add heading and forward movement to command list
        Commands.append([Heading2Pos, DriveDist, AutoPathChosen[x][3]])
        
    # Loop through commands and excecute them
    for x in Commands:
        # Uses 'ShortestRotation()' to decide wether to turn left or right

        if (x == WingExpands[0]):
            OnUpArrowPress()
        # -- Replaces drivetrain.turn_to_heading()
        drivetrain.turn(ShortestRotation(x[0], drivetrain_inertial.heading(DEGREES)))
        WaitUntilHeading(x[0], 2)
        drivetrain.stop()
        # --
        if x[2] == True:
            drivetrain.set_drive_velocity(60, PERCENT)
        else:
            drivetrain.set_drive_velocity(40, PERCENT)
        drivetrain.drive_for(REVERSE, x[1], MM, wait=True)

#




# Most of the driver control code is handled withn VEX's built in drivetrain configurator
def driver_control():
    drivetrain.stop()
    drivetrain.set_stopping(COAST)
    drivetrain.set_drive_velocity(40, PERCENT)
    drivetrain.set_turn_velocity(30, PERCENT)
    # Loop
    while True:
        wait(15, MSEC)
        brain.screen.set_pen_color(Color.RED)
        brain.screen.clear_screen()
        if Catapult_motor_a.temperature(PERCENT) >= 70:

            brain.screen.set_cursor(0, 0)
            brain.screen.print("TEMP OVER 60%, Catapult motor A")
        if Catapult_motor_b.temperature(PERCENT) >= 70:
            brain.screen.set_cursor(10, 0)
            brain.screen.print("TEMP OVER 60%, Catapult motor B")


# Pre-Start calibration
cometition = Competition(driver_control, autonomous)
calibrate_drivetrain()
drivetrain_inertial.set_heading(0, DEGREES)
Catapult.set_velocity(50, PERCENT)

Catapult.set_stopping(HOLD)

controller_1.buttonX.pressed(OnXPress)
controller_1.buttonX.released(OnXRelease)
controller_1.buttonUp.pressed(OnUpArrowPress)
controller_1.buttonL2.pressed(OnLeftBumperPress)
controller_1.buttonR2.pressed(OnRightBumperPress)
controller_1.buttonB.pressed(OnBPress)
controller_1.buttonB.released(OnBRelease)
# COMMENT OUT THIS AT START 
autonomous()
driver_control()
